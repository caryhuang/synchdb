diff --git a/oracle_parser_orig/liboracle_parser.c b/oracle_parser/liboracle_parser.c
index cfd1e80..c10cd6c 100644
--- a/oracle_parser_orig/liboracle_parser.c
+++ b/oracle_parser/liboracle_parser.c
@@ -74,7 +74,8 @@ typedef struct JumbleState
 	int			highest_extern_param_id;
 } JumbleState;
 
-/* saved hook value */
+/* saved hook value - not needed */
+/*
 static raw_parser_hook_type prev_raw_parser = NULL;
 static get_keywords_hook_type prev_pg_get_keywords = NULL;
 static fill_in_constant_lengths_hook_type prev_fill_in_contant_lengths = NULL;
@@ -82,17 +83,19 @@ quote_identifier_hook_type prev_quote_identifier = NULL;
 
 void _PG_init(void);
 void _PG_fini(void);
+*/
 
 static int	oracle_comp_location(const void *a, const void *b);
 
-static List * oracle_raw_parser(const char *str, RawParseMode mode);
+/* only export raw parser routine */
+extern PGDLLEXPORT List * oracle_raw_parser(const char *str, RawParseMode mode);
+
 static Datum oracle_pg_get_keywords(PG_FUNCTION_ARGS);
 static void oracle_fill_in_constant_lengths(void *jjstate, const char *query, int query_loc);
 static const char * oracle_quote_identifier(const char *ident);
 
+/* as a standalone raw parser there is no need for changing parser hooks */
 /*
- * Module load callback
- */
 void
 _PG_init(void)
 {
@@ -107,9 +110,6 @@ _PG_init(void)
 	quote_identifier_hook		  = oracle_quote_identifier;
 }
 
-/*
- * Module unload callback
- */
 void
 _PG_fini(void)
 {
@@ -118,6 +118,7 @@ _PG_fini(void)
 	fill_in_constant_lengths_hook = prev_fill_in_contant_lengths;
 	quote_identifier_hook		  = prev_quote_identifier;
 }
+*/
 
 /*
  * comp_location: comparator for qsorting pgssLocationLen structs by location
@@ -149,7 +150,7 @@ static char *str_udeescape(const char *str, char escape,
  * list have the form required by the specified RawParseMode.
  */
 
-static List *
+List *
 oracle_raw_parser(const char *str, RawParseMode mode)
 {
 	ora_core_yyscan_t yyscanner;
@@ -1118,7 +1119,8 @@ invalid_pair:
 	return NULL;				/* keep compiler quiet */
 }
 
-static Datum
+
+__attribute__((unused)) static Datum
 oracle_pg_get_keywords(PG_FUNCTION_ARGS)
 {
 	FuncCallContext *funcctx;
@@ -1188,7 +1190,7 @@ oracle_pg_get_keywords(PG_FUNCTION_ARGS)
 	SRF_RETURN_DONE(funcctx);
 }
 
-static void
+__attribute__((unused)) static void
 oracle_fill_in_constant_lengths(void *jjstate, const char *query,
 						 int query_loc)
 {
@@ -1287,7 +1289,7 @@ oracle_fill_in_constant_lengths(void *jjstate, const char *query,
 	ora_scanner_finish(yyscanner);
 }
 
-static const char *
+__attribute__((unused)) static const char *
 oracle_quote_identifier(const char *ident)
 {
 	/*
@@ -1364,3 +1366,144 @@ oracle_quote_identifier(const char *ident)
 
 	return result;
 }
+
+/* to resolve standalone compile error */
+char *
+downcase_identifier(const char *ident, int len, bool warn, bool truncate)
+{
+	char	   *result;
+	int			i;
+	bool		enc_is_single_byte;
+
+	result = palloc(len + 1);
+	enc_is_single_byte = pg_database_encoding_max_length() == 1;
+
+	/*
+	 * SQL99 specifies Unicode-aware case normalization, which we don't yet
+	 * have the infrastructure for.  Instead we use tolower() to provide a
+	 * locale-aware translation.  However, there are some locales where this
+	 * is not right either (eg, Turkish may do strange things with 'i' and
+	 * 'I').  Our current compromise is to use tolower() for characters with
+	 * the high bit set, as long as they aren't part of a multi-byte
+	 * character, and use an ASCII-only downcasing for 7-bit characters.
+	 */
+	for (i = 0; i < len; i++)
+	{
+		unsigned char ch = (unsigned char) ident[i];
+
+		if (ch >= 'A' && ch <= 'Z')
+			ch += 'a' - 'A';
+		else if (enc_is_single_byte && IS_HIGHBIT_SET(ch) && isupper(ch))
+			ch = tolower(ch);
+		result[i] = (char) ch;
+	}
+	result[i] = '\0';
+
+	if (i >= NAMEDATALEN && truncate)
+		truncate_identifier(result, i, warn);
+
+	return result;
+}
+
+char *
+upcase_identifier(const char *ident, int len, bool warn, bool truncate)
+{
+	char	   *result;
+	int			i;
+	bool		enc_is_single_byte;
+
+	result = palloc(len + 1);
+	enc_is_single_byte = pg_database_encoding_max_length() == 1;
+
+	/*
+	 * SQL99 specifies Unicode-aware case normalization, which we don't yet
+	 * have the infrastructure for.  Instead we use toupper() to provide a
+	 * locale-aware translation.  However, there are some locales where this
+	 * locale-aware translation.  However, there are some locales where this
+	 * is not right either (eg, Turkish may do strange things with 'i' and
+	 * 'I').  Our current compromise is to use toupper() for characters with
+	 * the high bit set, as long as they aren't part of a multi-byte
+	 * character, and use an ASCII-only downcasing for 7-bit characters.
+	 */
+	for (i = 0; i < len; i++)
+	{
+		unsigned char ch = (unsigned char) ident[i];
+
+		if (ch >= 'a' && ch <= 'z')
+			ch -= 'a' - 'A';
+		else if (enc_is_single_byte && IS_HIGHBIT_SET(ch) && islower(ch))
+			ch = toupper(ch);
+		result[i] = (char) ch;
+	}
+	result[i] = '\0';
+
+	if (i >= NAMEDATALEN && truncate)
+		truncate_identifier(result, i, warn);
+
+	return result;
+}
+
+char *
+identifier_case_transform(const char *ident, int len)
+{
+	char *upper_ident = NULL, *lower_ident = NULL, *result = NULL;
+
+	upper_ident = upcase_identifier(ident, len, true, true);
+	lower_ident = downcase_identifier(ident, len, true, true);
+
+	if (strcmp(upper_ident, ident) == 0)
+	{
+		result = lower_ident;
+		pfree(upper_ident);
+	}
+	else if (strcmp(lower_ident, ident) == 0)
+	{
+		result = upper_ident;
+		pfree(lower_ident);
+	}
+	else
+	{
+		result = palloc0(len + 1);
+		memcpy(result, ident, len);
+		pfree(upper_ident);
+		pfree(lower_ident);
+	}
+
+	return result;
+}
+
+void
+truncate_identifier(char *ident, int len, bool warn)
+{
+	if (len >= NAMEDATALEN)
+	{
+		len = pg_mbcliplen(ident, len, NAMEDATALEN - 1);
+		if (warn)
+			ereport(NOTICE,
+					(errcode(ERRCODE_NAME_TOO_LONG),
+					 errmsg("identifier \"%s\" will be truncated to \"%.*s\"",
+							ident, len, ident)));
+		ident[len] = '\0';
+	}
+}
+
+/*
+ * Determine whether the letters in the string are all uppercase letters
+ */
+bool
+is_all_upper(const char *src, int len)
+{
+	int		i;
+	const char	*s;
+
+	s = src;
+
+	for (i = 0; i < len; i++)
+	{
+		if (isalpha(*s) && islower(*s))
+			return false;
+		s++;
+	}
+
+	return true;
+}
